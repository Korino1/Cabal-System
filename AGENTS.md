# Operating Guide (Core)

> Ядро правил.  Подробные плейбуки и команды — в `.memory/CONTEXT.md`.
> Миссия/контекст/таски/прогресс — в `.memory/*`. Контракты — в `spec/contracts/*`. ADR — в `spec/adr/*` (индекс — `.memory/DECISIONS.md`). Спецификации и SDD — в `spec/docs/*`.
> Система учета/восстановления — `.memory/TRACKING.md`, `.memory/STATE.md`, `.memory/GLOBAL_INDEX.md`, `.memory/PHASES/*`, `.memory/DEFECTS.md`

Агент работает в стиле SDD: **Contracts → Tests → Code → ADR → Progress**.

---

## 0) Роли и консультации
Системный автоцикл (обязателен):
1) Если нет явного концепта/пояснений — запроси их до любого действия.
2) Прочитай `.memory/LOGIC_PROTOCOL.md` и определи текущий этап протокола 3.1.
3) Определи следующего Агент (conceptualizer/global-architect/orchestrator/architect/integrator-runtime/mathematician/qa-agent).
4) Запусти/назначь Агент строго по протоколу 3.1.
5) После завершения обнови `.memory/LOGIC_PROTOCOL.md` и `.memory/STATE.md`.
6) Если протокол 3.1 не завершён — вернись к шагу 2.
7) При противоречиях — `CONSULT` в `.memory/TASKS.md`.
- Пользователь — **Пользователь проекта**: формулирует цели, утверждает архитектурные решения и приоритеты.
- Агент — **единственный исполнитель**: разрабатывает код, проектирует архитектуру и декомпозирует задачи, но делает это только после согласования ключевых развилок с Пользователем. Пол агента мужской.
- Язык общения — только русский: отвечай, задавай уточнения и готовь отчёты на русском языке, если прямо не оговорено иное.
- Во время выполнения любой задачи регулярно оценивай, не появились ли неоднозначности или развилки, способные усложнить проект; при их обнаружении приостанови реализацию и инициируй консультацию с Пользователем.
- При любом появлении альтернативных подходов, спорных вопросов или необходимости усложнить архитектуру остановись и запроси консультацию Пользователя до продолжения работы.
- Перед запросом фиксируй контекст и вопросы в `.memory/TASKS.md` (с префиксом `CONSULT`/`REFLECT`, см. раздел «Практика CONSULT/REFLECT» ниже) и в `.memory/PHASES/<Active>/WORKLOG.md`.

### Практика CONSULT/REFLECT
- Каждую нетривиальную развилку (варианты архитектуры, изменение контрактов, выбор зависимостей, изменение SLA) предваряй отдельной задачей `CONSULT — …` с описанием вопросов к Пользователю.
- Если требуется осмыслить риски/альтернативы или подготовить аргументы до разговора, заводи `REFLECT — …` и используй её для фиксации анализа до эскалации вопроса.
- При декомпозиции фазы проверяй, что на каждую новую крупную область (очередь, воркеры, безопасность, UI) добавлены соответствующие `CONSULT`/`REFLECT` подпункты.
- После консультации перенеси решения в `.memory/PHASES/<Active>/WORKLOG.md` и обнови статус задачи; если решение требует действий — создай связанные имплементационные подзадачи.
- Под каждую ветку Kanban заводи служебный узел управления `US {идентификатор}.GOV` (или `US {идентификатор}.Discovery`), первым потомком которого идут `T … — CONSULT …`/`REFLECT …`; задачи реализации ниже раскрывай только после закрытия этих карточек.
- В `.memory/TASKS.md` храни шаблон блока с `GOV`-узлом и копируй его при создании новых веток, чтобы CONSULT/REFLECT автоматически попадали внутрь дерева.
- Перед стартом дочерних `US/T` проверяй, что родительский `GOV`-узел отмечен `[x]`; пока он `[ ]`, зависимые карточки остаются «не начаты».

### CONSULT по математике (обязательно)
- Все вопросы по формулам, соотношению параметров и математической корректности выносятся на Консультацию через агента `mathematician`.
- Математик определяет допустимые коридоры параметров исходя из цели проекта.
- Если параметр можно задавать в диапазоне, фиксировать три уровня:
  - `default` (средний),
  - `strict` (жёсткий),
  - `soft` (мягкий).



## 1) Must-Read перед задачей
Прочти файлы из мемори банка `.memory/`
Последовательность чтения:
1) `.memory/MISSION.md` → зачем/ценность/scope.
2) `.memory/CONTEXT.md` → окружения, стек, команды, quality policy, Deprecation.
3) `.memory/TASKS.md` → активные задачи (запомни id/owner).
4) `.memory/ASKS.md` → история пользовательских запросов.
5) `.memory/DECISIONS.md` → индекс ADR (учти `status/supersedes`) + соответствующие файлы в `spec/adr/`.
6) `spec/contracts/*` + `spec/contracts/VERSION.json` → версия API и изменения.
7) `.memory/USECASES.md` → сценарии + acceptance criteria.
8) `spec/docs/CONCEPT_MASTER.md` + `spec/docs/CONCEPT_MATH_PROOF.md` → канон концепта и математическое обоснование (если созданы).
9) `.memory/INDEX.yaml` → быстрый контроль актуальности артефактов.
10) `.memory/TRACKING.md` → регламент учета/восстановления.
11) `.memory/STATE.md` → точка продолжения (snapshot).
12) `.memory/GLOBAL_INDEX.md` → активная фаза и реестр фаз (источник истины).
13) `.memory/PHASES/<Active>/INDEX.md` → контекст активной фазы.
14) `.memory/PHASES/<Active>/STATE_HISTORY.md` → история снимков фазы (append-only).
15) `scripts/checkpoint.ps1` → единый снимок состояния.
16) `.memory/DEFECTS.md` → handoff дефектов (debuger → fixer).

## 1.1) Первый запуск (если файлы пустые)
- Заполни `MISSION.md`, `CONTEXT.md`, `GLOSSARY.md`, `USECASES.md`. Допускается использовать LLM для первичного черновика на основе проекта.


## 2) Рабочий журнал
- До checkpoint все шаги записывай в `.memory/PHASES/<Active>/WORKLOG.md`.
- После прохождения checkpoint (см. ниже) — синхронизируй `.memory/TASKS.md`, `.memory/PROGRESS.md`, при необходимости — `.memory/DECISIONS.md` и `.memory/ASKS.md`.

## 3) Канонический процесс (SDD)
1) Любые изменения поведения/публичных интерфейсов — **сначала** `spec/contracts/*`.
2) Добавь/обнови unit + contract-тесты; прогон pre-commit чек-листа (см. CONTEXT).
3) Внеси минимально достаточные изменения кода.
4) Если принято архитектурное решение — оформи ADR в `spec/adr/ADR-XXXX.md` и обнови индекс `.memory/DECISIONS.md`.
5) Обнови прогресс (после checkpoint): `.memory/PROGRESS.md` (1 строка), `.memory/ASKS.md` (фиксируй выполненный запрос) и статус задачи в `.memory/TASKS.md`.
## 3.1) Логическая схема создания больших проектов (протокол)
Канон протокола, этапы и подробные требования — в `.memory/LOGIC_PROTOCOL.md` (не дублируются здесь).
Минимальные правила для исполнения:
- Следовать текущему этапу протокола из `.memory/LOGIC_PROTOCOL.md`, без перескока и расширения scope.
- Один агент = один объект работы на сессию (блок/метод/функция).
- Результаты писать строго в `.memory/*` согласно активной фазе.
- Любые противоречия/неоднозначности фиксировать как `CONSULT` в `.memory/TASKS.md`.
- Для каждого этапа использовать каноническую структуру фазы (Purpose/Inputs/Outputs/Entry/Exit/Evidence) из `.memory/LOGIC_PROTOCOL.md`.
- Перед сменой фазы проходить чеклист `spec/docs/PHASE_GATE.md`.
- Любые изменения `LOGIC_PROTOCOL.md` оформлять ADR в `spec/adr/ADR-XXXX.md` и обновлять `.memory/DECISIONS.md`.
- Rust‑engineer начинает код только после завершения GA‑5 и наличия описаний функций.
- Сквозные правила из `spec/docs/CONCEPT_MASTER.md` (раздел 6) обязательны для всех исполнителей на любой итерации.
- Каждая итерация реализации должна проходить QA-анти-имитацию (`qa-agent`) и иметь `QA:PASS`; заглушки/упрощения/имитации запрещены.
## 3.1.2) Приоритет источников концепта
- Канон: `spec/docs/CONCEPT_MASTER.md` + `spec/docs/CONCEPT_MATH_PROOF.md`.
- Первичные материалы перечисляются внутри `CONCEPT_MASTER.md` и используются только для верификации.
- При спорных ситуациях приоритет у канона (`CONCEPT_MASTER.md` + `CONCEPT_MATH_PROOF.md`); расхождения фиксировать как `CONSULT`.


## 3.1.1) Правила агентов для логической схемы
- Детальные правила, шаблоны и критерии — в `.memory/LOGIC_PROTOCOL.md`.
## 4) Checkpoints (минимум)
Считается пройденным, если одновременно:
- `spec/contracts/*` валидны и версия в `spec/contracts/VERSION.json` обновлена по правилам SemVer (MAJOR/MINOR/PATCH);
- unit + contract тесты зелёные;
- ADR (если нужно) создан/обновлён (`spec/adr/` + `.memory/DECISIONS.md`);
- в `PHASES/<Active>/WORKLOG.md` зафиксированы шаги, согласованные с Пользователем.


## 5) Правила 
 - Работаем по принципу KISS. Не усложняй, производи только критически необходимые проверки и валидации.

## 6) Антипаттерны (запрещено)
- Менять публичные контракты без `spec/contracts/*` и VERSION bump.
- Игнорировать синхронизацию `.memory/ASKS.md` и `.memory/PROGRESS.md` после завершения задачи.
- Вносить «временные» костыли без ADR/срока удаления.
- Коммитить секреты/ключи; нарушать лицензионные условия.


## 7) Кодировочная дисциплина (UTF-8)
- Все текстовые артефакты хранятся в UTF-8 без BOM; не «упрощай» содержимое ради ASCII.
- При работе из PowerShell явно указывай кодировку: `Get-Content -Raw -Encoding UTF8 …`, `Set-Content … -Encoding UTF8`; не используй команды без `-Encoding UTF8`.
- Перед любым выводом текста в PowerShell принудительно выставляй консольную кодировку: `[Console]::InputEncoding = [Console]::OutputEncoding = [System.Text.Encoding]::UTF8; <команда>`. Пример: `powershell.exe -NoLogo -Command "[Console]::InputEncoding=[Console]::OutputEncoding=[System.Text.Encoding]::UTF8; Get-Content -Raw -Encoding UTF8 '.memory/CONTEXT.md'"`!
- Для скриптовых правок предпочитай `py -X utf8 -c "…"`, а для точечных изменений — `apply_patch`; это исключает двойное перекодирование.
- После правок проверяй, что файл читается как UTF-8 (`py -X utf8 -c "from pathlib import Path; Path(...).read_text(encoding='utf-8')"`) и что `git diff` не содержит «Р…» артефактов.

## 8) Формат вывода команд
Если пишешь мне команды - каждую команду выводи в отдельном фрейме через три обратных апострофа(для удобного копирования команды).






















